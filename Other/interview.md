# 面经
## 一）. 操作系统

### 1. 进程的状态以及各个状态之间的切换
- 就绪:进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行
- 执行:进程已经获得CPU，程序正在执行状态
- 阻塞:正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态

### 2. 进程和线程
- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的基本单位
- 线程是进程的一个实体，是CPU调度和分派的基本单位

#### 2.1 进程和线程的关系

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段用来存放所有局部变量和临时变量
- 处理机分给线程，即真正在处理机上运行的是线程
- 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步

#### 2.2 线程与进程的区别
- 进程有自己独立的地址空间，线程没有
- 进程是系统资源分配的最小单位，线程是CPU调度的最小单位
- 进程和线程通信方式不同（线程之间的通信比较方便。同一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。）
- 进程上下文切换开销大，线程开销小
- 一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程
- 对进程操作一般开销都比较大，对线程开销小

#### 2.3 为什么进程上下文切换比线程上下文切换代价高
- 进程的步骤是：
	- 1. 切换全局目录
	- 2. 切换内核栈
	- 3. 切换硬件上下文
线程和进程的最大区别就在于地址空间，对于线程切换，第一步是不需要做的。
- 切换全局目录的性能消耗：
	- 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的是最显著的性能损耗是将寄存器中的内容切换出
	- 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题

### 3. 进程同步

### 4. 进程的通信方式有哪些
- 管道：管道是单向、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因为，主要作为进程间及同一进程内不同线程之间的同步手段。
- 消息队列：是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限制等缺点。
- 共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。这一段内存可以被两个或两个以上的进程映射到自身的地址空间中，一个进程写入功效内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制（如信号量）配合使用，来实现进程间的同步和通信
- 套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信

## 二）. 计算机网络

### 1. Http和Https的区别
Http协议运行在TCP之上，明文传输，客户端与服务器都无法验证对方的身份；Https是身披SSL（Secure Socket Layer）外壳Http，运行在SSL上，SSL运行在TCP之上，是添加了加密和认证机制的HTTP。Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。
#### 主要不同：
- 端口不同：http与https使用的连接方式不同，用的端口也不一样，http是80端口，https是443端口；
- 资源消耗：https由于加减密处理消耗更多的CPU和内存资源；
- 开销：https通信需要证书，而证书一般需要向认证机构购买；

### 2. 对称加密与非对称加密
   对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
   由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 3. TCP协议保证传输的可靠性
TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
#### 对于可靠性，TCP通过以下的方式进行保证：
- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不会给出响应，这时TCP发送数据端超时后会重发数据；
- 对失效数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- 丢弃重复数据：对于重复数据，能够丢弃重复数据；
- 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接受端只允许另一端发送接受端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

### 4. TCP和UDP的区别：
- TCP是面向连接的，UDP是无连接的；
- TCP是可靠的，UDP是不可靠的；
- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
- TCP是面向字节流的，UDP是面向报文的；
- TCP有拥塞控制机制；UDP没有拥塞控制，适合媒体通信；
- TCP首部开销（20个字节）比UDP的首部开销（8个字节）要大；
- TCP常见应用层协议：FTP(21)， Telnet(23)， SMTP(25), POP3(110), HTTP(80);UDP常见应用层协议：DNS(53)，SNMP(161)，TFTP(69)；

### 5. TCP的拥塞处理
计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：
1. 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小；
2. 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长；
3. 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚为收到的报文段，而不必继续等待设置的重传计时器时间到期；
4. 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

### 6. Http
#### HTTP请求信息由3部分组成：
1. 请求方法（GET/POST）、URI、协议/版本
2. 请求头(Request Header)：Content-Type、端口号Host、Cookie
3. 请求正文：包含客户提交的查询字符串信息
请求头和请求正文之间是一个空行
#### HTTP响应也由3个部分构成：
1. 状态行：状态代码及描述 如404、500
2. 响应头(Response Header)：Content-Type 、Server、Date
3. 响应正文：html代码
#### HTTP常见状态码
- 200 ：请求成功，成功返回网页
- 301 ：资源（网页等）被永久转移到其它URL
- 302 ：资源（网页等）被临时转移到其它URL
- 304 ：请求未修改、命中缓存
- 401 ：未授权
- 403 ：服务器拒绝请求
- 404 ：请求的网页或资源不存在
- 500 ：内部服务器错误，无法完成请求
- 502 ：错误网关
- 503 ：请求未完成，服务器临时过载或宕机
- 504 ：网关超时

### 7. Http请求方法
1. GET:请求指定的页面信息，并返回实体主体；
2. HEAD：类似于GET请求，不过返回的响应中没有具体的内容，用于获取报头；
3. POST：向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改；
4. PUT:从客户端向服务器传送的数据取代指定的文档的内容；
5. DELETE：请求服务器删除指定的页面；
6. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器；
7. OPTIONS：允许客户端查看服务器的性能；
8. TRACE：回显服务器收到的请求，主要用于测试或诊断；

### 8. 从输入网址到获取页面的过程
1. 浏览器查询DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域的资源中，则返回解析结果给客户机，完成域名解析；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析。如果本地域名服务器并为缓存该网址映射关系，那么将根据其设置发起递归查询或迭代查询；
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手；
3. TCP/IP连接建立起来后，浏览器向服务器发送http请求；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

### 9. Session,Cookie与Application
Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。
- Cookie及其相关的API：Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie，而客户端浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该cookie一同提交给服务器，服务器检查该cookie，以此来辨认用户状态。服务器还可以根据需要修改cookie的内容。
- Session：同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为次客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用cookie机制，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器；若浏览器禁用cookie的话，可以用过URL重写机制将sessionid传回服务器;
- Session与Coookie对比：
	- 实现机制：Session的实现常常依赖于cookie机制，通过cookie机制回传sessionid；
	- 大小限制：cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，session没有大小限制，理论上只与服务器的内存大小有关；
	- 安全性：cookie存在安全隐患，通过拦截或本地文件找到cookie后可以进行攻击，而session由于保存在服务器端，相对更加安全；
	- 服务器资源消耗：session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力；
- Application：与一个web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态；

## 三）. C++
## 四）. Docker
### 1. 什么是docker
Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。

### 2. docker与虚拟机不不同
Docker不是虚拟化方法。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。为此，Docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。
1. 容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取。
2. 由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能。
3. 对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件。
4. 主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。
5. 与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发。
6. 容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似。

## 五）. Websocket 
### 1. 什么是websocket
WebSocket是HTML5一种新的协议，WebSocket是真正实现了全双工通信的服务器向客户端推的互联网技术，是一种在单个TCP连接上进行全双工通讯协议。

### 2. http与websocket的区别
http协议是短链接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开连接。WebSocket协议是一种长连接，只需要通过一次请求来初始化链接，然后所有的请求和响应都是通过这个TCP链接进行通信。websocket相对与http的头部多了一个upgrade信息。

## 六）. kafka
### 1. 什么是kafka
Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，之后成为Apache项目的一部分，Kafka是一个分布式，可划分的，冗余备份的持久性的日志服务，它主要用于处理流式数据。

### 2.为什么要使用 kafka，为什么要使用消息队列
- 缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。
- 解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。
- 冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。
- 健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。
- 异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。


## 七）. 数据库
## 八）. linux
## 九）. algorithm
